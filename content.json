{"meta":{"title":"戎码一生","subtitle":"反正山高水长，还有一生可以嚣张","description":"反正山高水长，还有一生可以嚣张","author":"捕风","url":"http://houxiaoyi.cn","root":"/"},"pages":[{"title":"tags","date":"2019-08-11T04:51:50.000Z","updated":"2019-08-19T11:34:31.516Z","comments":true,"path":"tags/index.html","permalink":"http://houxiaoyi.cn/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-08-11T04:52:21.000Z","updated":"2019-08-19T11:34:31.516Z","comments":true,"path":"categories/index.html","permalink":"http://houxiaoyi.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Java 泛型","slug":"Java-泛型","date":"2019-08-22T12:58:58.000Z","updated":"2019-08-27T02:45:07.525Z","comments":true,"path":"2019/08/22/Java-泛型/","link":"","permalink":"http://houxiaoyi.cn/2019/08/22/Java-泛型/","excerpt":"","text":"Java 泛型简单点就是一个占位符，这个型是任意的，所以就是叫做泛型，也就是&lt;AnyWord&gt; 尖括号里面的字符是任意的，但是在上下文中应该是一致的，它标识统一类型，至于是什么类型，后期使用者自己觉得，所以重复一遍，泛型可以简单理解为占位符。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class GeneticProgramming &#123; public static void main(String[] args) &#123; Box&lt;String&gt; box = new Box&lt;String&gt;(); box.set(\"Hello World！\"); String a = box.get(); System.out.println(a); Cox&lt;Integer&gt; cox = new Cox&lt;Integer&gt;(); cox.set(12); int b = cox.get(); System.out.println(b); &#125;&#125;class Box&lt;T&gt; &#123; // T stands for \"Type\" private T t; public void set(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125;&#125;class Cox&lt;AnyValue&gt; &#123; // AnyValue stands for \"Type\" private AnyValue t; public void set(AnyValue t) &#123; this.t = t; &#125; public AnyValue get() &#123; return t; &#125;&#125; 在Java的源代码中比较常见的泛型有HashMap&lt;K,V&gt;，其中的K，V。都是泛型的表示，如果有兴趣可以看下源代码。 1234567891011121314public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; private static final long serialVersionUID = 362498820763181265L; public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125;&#125; 上面只是部分源代码，可以看出HashMap对泛型的应用。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://houxiaoyi.cn/tags/Java/"}]},{"title":"Logback框架的配置文件","slug":"Logback框架的配置文件","date":"2019-08-19T14:16:11.000Z","updated":"2019-08-27T02:51:44.352Z","comments":true,"path":"2019/08/19/Logback框架的配置文件/","link":"","permalink":"http://houxiaoyi.cn/2019/08/19/Logback框架的配置文件/","excerpt":"","text":"SpringBoot中使用的是面向日志框架是slf4j，使用的日志框架应该是logback。因此可以直接在SpringBoot中使用。 1private final static org.slf4j.Logger logger = org.slf4j.LogFactory.getLogger(ClassName.class); 没有配置文件，直接去使用虽然没有太大问题问题，但是如果要详细配置输出文件，以及日志等级，可能就需要详细的设计了。 logback详细配置显示文件行数，点击可以跳转。需要在application.properties中配置 12# log configlogging.config=classpath:logback.xml logback.xml文件内容如下 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration debug=\"false\" scan=\"true\" scanPeriod=\"1 seconds\"&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;property name=\"log.path\" value=\"/tmp/applogs/xxl-job/xxl-job-executor-sample-springboot.log\"/&gt; &lt;appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %highlight(%-5level) %yellow(at %class.%method) \\(%file:%line\\) - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"file\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;file&gt;$&#123;log.path&#125;&lt;/file&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;.%d&#123;yyyy-MM-dd&#125;.zip&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%date %level [%thread] %logger&#123;36&#125; [%file : %line] %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"console\"/&gt; &lt;appender-ref ref=\"file\"/&gt; &lt;/root&gt;&lt;/configuration&gt; 效果如下图 logback.png eclipse版本的SpringBoot的内置logback配置由于eclipse的console并不能输出各种彩色，只能输出蓝色，红色以及黑色。因此基于idea版本去掉了特殊颜色设置。 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration debug=\"false\" scan=\"true\" scanPeriod=\"1 seconds\"&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;property name=\"log.path\" value=\"/tmp/applogs/xxl-job/xxl-job-executor-sample-springboot.log\"/&gt; &lt;appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level at %class.%method \\(%file:%line\\) - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"file\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;file&gt;$&#123;log.path&#125;&lt;/file&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;.%d&#123;yyyy-MM-dd&#125;.zip&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%date %level [%thread] %logger&#123;36&#125; [%file : %line] %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"debug\"&gt; &lt;appender-ref ref=\"console\"/&gt; &lt;appender-ref ref=\"file\"/&gt; &lt;/root&gt;&lt;/configuration&gt; 参考：https://logback.qos.ch/manual/layouts.html","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://houxiaoyi.cn/tags/Java/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-08-19T11:34:31.512Z","updated":"2019-08-19T11:34:31.512Z","comments":true,"path":"2019/08/19/hello-world/","link":"","permalink":"http://houxiaoyi.cn/2019/08/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"数据结构-插入排序","slug":"数据结构-插入排序","date":"2019-08-19T11:26:22.000Z","updated":"2019-08-19T11:34:31.512Z","comments":true,"path":"2019/08/19/数据结构-插入排序/","link":"","permalink":"http://houxiaoyi.cn/2019/08/19/数据结构-插入排序/","excerpt":"","text":"C语言实现的插入排序算法两种实现方式 代码繁多（逻辑简单） 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;int main()&#123; int a[10]=&#123;2,4,7,3,1,9,8,6,0,5&#125;; for(int i=1;i&lt;10;i++) &#123; int k=i; for(int j=i-1;j&gt;=0;j--) &#123; if(a[i]&lt;a[j]) &#123; k=j; &#125; &#125; //k为a[i]应该所在的位置 //置换位置 int temp=a[i]; for (int m=i;m&gt;k;m--) &#123; a[m]=a[m-1]; &#125; a[k]=temp; &#125; for(int h=0;h&lt;10;h++) &#123; printf(\"%d\",a[h]); &#125; return 0;&#125; 代码简洁（逻辑复杂） 12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; int a[10] = &#123;2,6,3,1,4,8,5,9,7,0&#125;; for(int i = 1 ; i&lt; 10 ; i++)&#123; int tem = a[i]; int j = i-1; while (j &gt;= 0&amp;&amp; a[j] &gt; tem) &#123; a[j+1] = a[j]; j--; &#125; a[++j]=tem; &#125; for (int i = 0; i &lt; 10; i++) &#123; printf(\"%d\",a[i]); &#125; return 0;&#125; 上面两种代码。代码简洁一般逻辑复杂，代码繁多的一般逻辑简单。逻辑简单一般符合机器思维，逻辑复杂一般符合人脑符合。 Java实现插入排序 12345678910111213141516171819public class InsertSort &#123; public static void main(String[] args) &#123; int[] a = &#123;2,6,3,1,4,8,5,9,7,0&#125;; for(int i=1;i&lt;10;i++) &#123; int tmp = a[i]; int j=i-1; while(j&gt;=0&amp;&amp;a[j]&gt;tmp) &#123; a[j+1]=a[j]; j--; &#125; a[++j]=tmp; &#125; for(int b:a) &#123; System.out.print(b); &#125; &#125;&#125; Java编辑的可以使用eclipse或者IDEA调试！方便找出问题所在，相比较于C语言要更加容器找到问题所在。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://houxiaoyi.cn/tags/数据结构/"}]},{"title":"Docker学习","slug":"Docker学习","date":"2019-08-11T04:45:56.000Z","updated":"2019-08-19T11:34:31.512Z","comments":true,"path":"2019/08/11/Docker学习/","link":"","permalink":"http://houxiaoyi.cn/2019/08/11/Docker学习/","excerpt":"","text":"docker基础命令重启docker1sudo service docker restart 常用命令12345678910111213141516171819202122# 开始一个新的容器$ JOB=$(sudo docker run -d ubuntu /bin/sh -c &quot;while true; do echo Hello world; sleep 1; done&quot;)# 停止容器$ docker stop $JOB# 开始容器$ docker start $JOB# 重启容器$ docker restart $JOB# 杀死一个工作$ docker kill $JOB# 删除一个容器$ docker stop $JOB # Container must be stopped to remove it$ docker rm $JOB# 查看所有容器$ docker ps -a #所有实例化的容器 容器内部操作进入容器内部 1docker exec -it ContainerId /bin/bash docker运行应用docker跑一个Tomcat第一步：拉取一个Tomcat镜像1docker pull tomcat 第二步：运行Tomcat实例化一个Tomcat容器 1docker run --name tomcat -p 8080:8080 -v $PWD/test:/usr/local/tomcat/webapps/test -d tomcat 实例化第二个Tomcat容器 1docker run --name tomcat2 -p 9080:8080 -v /home/eric/Project/Docker/tomcat2/webapps/test:/usr/local/tomcat/webapps/test -d tomcat 命令说明： -p 8080:8080：将容器的8080端口映射到主机的8080端口 -v $PWD/test:/usr/local/tomcat/webapps/test：将主机中当前目录下的test挂载到容器的/test查看容器启动情况","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://houxiaoyi.cn/tags/Docker/"}]}]}